% this file is loaded at the start of the system


:- export key/1.

%:- macro key/1.  % declare that the key expression is a macro.  This will be something that should take the AST for something, but what is the name that is going to be used by this expression then?  Are we just going to quote escape its arguments.  Are we going to give it the entire AST for its arguments including

:- dispose key(quote1).
:- make_global_term key/1.
key(QuotedName) = $reflect(QuotedName, Dynabase, Name, _),
                  $get_key_for_expression(Dynabase, Name, QuotedName).

% the macros for a given arity of a function will
%% key(AST) = $reflect(AST, Dynabase, Name, Args),
%%            &$get_key_for_expression(Dynabase, Name, Args).

% want to be able to do something like key(foo(X)) and then this will instead get


:- export list/1.
:- make_global_term list/1.
% for annotation that somethign is a list.  This will match against all list types
list([]).
list([_|A]) :- list(A).

:- export list/2.
:- dispose list(quote1, eval).
:- make_global_term list/2.
% allows for type annotation against something.  This
list(Type, []).
list(Type, [X|A]) :- *Type(X), list(Type, A).


%% $eval_list([]) = [].
%% $eval_list([X|A]) = [$eval(X)|$eval_list(A)].


:- export list_length/1.
:- make_global_term list_length/1.
list_length([]) = 0.
list_length([X|A]) = list_length(A) + 1.


:- export append/3.
:- make_global_term append/3.
append([], A, A).
append([X|Y], A, [X|B]) :- append(Y, A, B).

:- export $with_key/2.
:- make_global_term $with_key/2.
$with_key(Value,Key) = &$with_key(Value,Key).

:- export in_list/2.
:- make_global_term in_list/2.
in_list([X|_], X).
in_list([_|Xs], X) :- in_list(Xs, X).
